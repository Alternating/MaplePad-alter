;
; Maple TX/RX by Charlie Cole
;

.program maple_tx
.side_set 1
.define HOLD	12
.define SETTLE	 6 ; Possibly could reduce
.define MID		 6 ; Possibly could reduce

; Start both high
; pins is pin 1
; side is pin 5
; autopull needs to be enabled
; packet size comes first then data
; run at around 48MHz

	set pindirs, 0		side 1 ; Set to input

	; set up loop
	pull				side 1 [HOLD]
	out x,32			side 1 ; size of packet in bit pairs - 1
	set pindirs, 3		side 1 ; Set to output

sync:
	set y,3				side 1
	set pins, 2			side 1 [HOLD]
syncloop:
	nop					side 0 [HOLD]
	jmp y-- syncloop	side 1 [HOLD]
	set pins, 3			side 1 [MID]
	nop 				side 0 [HOLD]

	; data
dataloop:
	out y, 1			side 0
	set pins, 1			side 0 [MID-1]
	jmp !y, send_zero	side 0
	
	; send zero
	nop					side 1 [SETTLE]
	set pins, 2			side 1 [HOLD]
	jmp outro			side 1 [MID]

send_zero:
	nop					side 0 [SETTLE]
	set pins, 0			side 0 [HOLD]
	nop					side 1 [MID]

outro:
	out pins, 1			side 1 [SETTLE]
	jmp x-- dataloop	side 0 [HOLD-1]

tail:
	set pins, 1			side 0 [HOLD]
	nop					side 1 [HOLD] 
	nop					side 0 [HOLD] 
	set pins, 0			side 0 [HOLD] 
	set pins, 1			side 0 [HOLD] 
	set pins, 0			side 0 [HOLD] 
	set pins, 1			side 0 [HOLD] 
	set pins, 3			side 1 [HOLD] 

% c-sdk {
static inline void maple_tx_program_init(PIO pio, uint sm, uint offset, uint pin1, uint pin5, float clkdiv) {
    pio_sm_config c = maple_tx_program_get_default_config(offset);

    // Map the state machine's OUT pin group to one pin, namely the `pin`
    // parameter to this function.
    sm_config_set_out_pins(&c, pin1, 1);
	sm_config_set_set_pins(&c, pin1, 2);
	sm_config_set_sideset_pins(&c, pin5);

	// autopull ever 32 bits (might as well pack it in)
	sm_config_set_out_shift(&c, false, true, 32);
	sm_config_set_clkdiv(&c, clkdiv);
	sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

	// Set the pin direction to output at the PIO
	pio_sm_set_pins_with_mask(pio, sm, (1u << pin1) | (1u << pin5), (1u << pin1) | (1u << pin5));
    pio_sm_set_pindirs_with_mask(pio, sm, 0, (1u << pin1) | (1u << pin5));
    
	// Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin1);
    pio_gpio_init(pio, pin5);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}

.program maple_rx_triple1
	wait 1 irq 7
	in pins, 2

.program maple_rx_triple2
	wait 0 pin 0
	irq 7
	wait 1 pin 0
	irq 7

.program maple_rx_triple3
	wait 0 pin 1
	irq 7
	wait 1 pin 1
	irq 7

% c-sdk {
static inline void maple_rx_triple_program_init(PIO pio, uint* offset, uint pin1, uint pin5, float clkdiv) {
	assert(pin5 == pin1+1);
	for (int sm = 0; sm < 3; sm++)
	{
		pio_sm_set_consecutive_pindirs(pio, sm, pin1, 2, false);

		pio_sm_config c = (sm == 0)?maple_rx_triple1_program_get_default_config(offset[0]):
			((sm == 1)?maple_rx_triple2_program_get_default_config(offset[1]):maple_rx_triple3_program_get_default_config(offset[2]));

		// Map the state machine's OUT pin group to one pin, namely the `pin`
		// parameter to this function.
		sm_config_set_in_pins(&c, pin1);

		// autopush every 8 bits (gives possibly 3 missed
		// transitions which is enough to still detect tail
		sm_config_set_in_shift(&c, false, true, 8);
		sm_config_set_clkdiv(&c, clkdiv);
		sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

		// Load our configuration, and jump to the start of the program
		pio_sm_init(pio, sm, offset[sm], &c);
	}
}
%}
